repeat
    task.wait();
until game:IsLoaded();

-- [LOADING SCREEN DARI FILE 2]
loadstring(game:HttpGet("https://raw.githubusercontent.com/ANHub-Script/ANUI/refs/heads/main/dist/loading.lua"))()

-- [MODIFIKASI 1: UPDATE FOLDER PATH]
local FolderPath = "ANUI/AnimeWeapons";
local ExpiryFile = FolderPath .. "/ANHub_Key_Timer.txt";
local ZoneDBFile = "Zone_Database.json";

local function SecureWipe()
    if not isfile or (not delfile) or (not readfile) or (not listfiles) then
        return;
    end;
    local currentTime = os.time();
    local isExpired = false;

    if isfile(ExpiryFile) then
        local savedTime = tonumber(readfile(ExpiryFile)) or 0;
        if currentTime > savedTime then
            isExpired = true;
        end;
    elseif isfolder(FolderPath) then
        isExpired = true;
    end;

    if isExpired then
        if isfile(ExpiryFile) then
            delfile(ExpiryFile);
        end;

        local PossiblePaths = {
            "ANUI/AnimeWeapons",
        };
        local UserId = tostring(game.Players.LocalPlayer.UserId);
        for _, path in pairs(PossiblePaths) do
            if isfolder(path) then
                for _, file in pairs(listfiles(path)) do
                    if string.find(file, ".key") or string.find(file, ".json") or string.find(file, UserId) then
                        pcall(function()
                            delfile(file);
                        end);
                    end;
                end;
            end;
        end;
        task.wait(0.5);
    end;
end;
SecureWipe();

local Players = game:GetService("Players");
local LocalPlayer = Players.LocalPlayer;
local Workspace = game:GetService("Workspace");
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local ReplicatedFirst = game:GetService("ReplicatedFirst");
local HttpService = game:GetService("HttpService");
local RunService = game:GetService("RunService");
local Reliable = (ReplicatedStorage:WaitForChild("Reply")):WaitForChild("Reliable");
local Unreliable = (ReplicatedStorage:WaitForChild("Reply")):WaitForChild("Unreliable");
local MaterialsModule = require(ReplicatedStorage.Scripts.Configs.General.Materials)
local TradeTokenInfo = MaterialsModule.TradeToken

if not isfolder("ANUI") then makefolder("ANUI") end
if not isfolder(FolderPath) then makefolder(FolderPath) end

local Config = {
    AutoFarm = false,
    AutoDungeon = false,
    AutoFuse = false,
    AutoRankUp = false,
    AutoYen_Luck = false,
    AutoYen_Damage = false,
    AutoYen_Yen = false,
    AutoYen_Mastery = false,
    AutoYen_Critical = false,
    AutoRollBiju = false,
    AutoRollRace = false,
    AutoRollSayajin = false,
    AutoRollFruits = false,
    AutoRollHaki = false,
    AutoRollBreathing = false,
    AutoRollOrganization = false,
    AutoRollTitan = false,
    AutoRollMagicEyes = false,
    AutoRollDemonArt = false,
    AutoUpgradeMagicEyes = false,
    AutoChance_Breath = false,
    AutoChance_Pirate = false,
    AutoChance_Wise = false,
    AutoChance_Leve = false,
    AutoChance_Sung = false,
    -- [ACCESSORIES CONFIG]
    AutoEquipAccessories = false,
    AccessoryInMode = nil,
    AccessoryOutMode = nil,
    TargetWaveDungeon = 500,
    TargetWaveRaid = 500,
    TargetWaveDef = 500,
    SelectedEnemy = nil,
    ZoneConfigurations = {},
    TargetDungeon = {},
    TargetRaid = {},
    TargetDefense = {}
};
local dontTeleport = false
local hrp, humanoid;
local LastZone = nil;
local CurrentZoneName = "";
local CurrentZoneEnemiesCache = {};
local IsLoadingConfig = false;
local IsTeleporting = false;
local GlobalEnemyMap = {};
local RollConfigs = {};
local LastEnemyScanTime = 0;
local LastEnemyChildCount = 0;
local AllRollTypes = {};
local HasJoinedGamemode = false;
local function DiscoverRollTypes()
    local set = {};
    local cfgRoot = ReplicatedStorage:FindFirstChild("Scripts") and ReplicatedStorage.Scripts:FindFirstChild("Configs");
    if not cfgRoot then
        return;
    end;
    local rollsFolder = cfgRoot:FindFirstChild("RollGachas");
    if rollsFolder then
        for _, child in pairs(rollsFolder:GetChildren()) do
            if child:IsA("ModuleScript") then
                set[child.Name] = true;
            end;
        end;
    end;
    local upgradesFolder = cfgRoot:FindFirstChild("RollGachaUpgrades");
    if upgradesFolder then
        for _, child in pairs(upgradesFolder:GetChildren()) do
            if child:IsA("ModuleScript") then
                set[child.Name] = true;
            end;
        end;
    end;
    AllRollTypes = {};
    for name, _ in pairs(set) do
        table.insert(AllRollTypes, name);
    end;
    table.sort(AllRollTypes);
end;
DiscoverRollTypes();
local ChanceUpgradeTypes = {
    "Breath",
    "Pirate",
    "Wise",
    "Leve",
    "Sung"
};
local EnemyDropdown = nil;
local RankProgressUI = nil;
local RollToggleUI = {};
local YenUpgradeToggleUI = {};
local TokenUpgradeToggleUI = {};
local ChanceUpgradeToggleUI = {};
(getgenv()).PlayerData = nil;

local function JSONPretty(val, indent)
    indent = indent or 0;
    local valType = type(val);
    if valType == "table" then
        local s = "{\n";
        for k, v in pairs(val) do
            local formattedKey = type(k) == "number" and tostring(k) or "\"" .. tostring(k) .. "\"";
            s = s .. string.rep("    ", indent + 1) .. formattedKey .. ": " .. JSONPretty(v, indent + 1) .. ",\n";
        end;
        return s .. string.rep("    ", indent) .. "}";
    elseif valType == "string" then
        return "\"" .. val .. "\"";
    else
        return tostring(val);
    end;
end;
local function ScanPlayerData()
    if (getgenv()).PlayerData then
        return;
    end;
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" then
            if rawget(v, "Attributes") and rawget(v, "YenUpgrades") then
                (getgenv()).PlayerData = v;
                break;
            end;
            if rawget(v, "Data") and type(rawget(v, "Data")) == "table" then
                local inner = rawget(v, "Data");
                if rawget(inner, "Attributes") and rawget(inner, "YenUpgrades") then
                    (getgenv()).PlayerData = inner;
                    break;
                end;
            end;
        end;
    end;
end;
task.spawn(ScanPlayerData);
local function InitAutoReconnectBypass()
    local targetFound = false;
    local function activateBypass(func, uiObject, numIndex)
        task.spawn(function()
            local applied = false;
            while true do
                debug.setupvalue(func, numIndex, 0);
                if uiObject and not applied then
                    uiObject.Visible = true;
                    uiObject.Text = "ANHub Bypass Reconnect V2";
                    uiObject.TextColor3 = Color3.fromRGB(0, 255, 100);
                    applied = true;
                end;
                task.wait(2);
            end;
        end);
    end;
    local function deepScan(func, path)
        if not islclosure(func) then
            return;
        end;
        local upvalues = debug.getupvalues(func);
        local foundUI = nil;
        local foundNumIndex = nil;
        for i, v in pairs(upvalues) do
            if typeof(v) == "Instance" and v.Name == "autoReconnect" then
                foundUI = v;
            end;
            if type(v) == "number" then
                foundNumIndex = i;
            end;
        end;
        if foundUI and foundNumIndex then
            if not targetFound then
                targetFound = true;
                activateBypass(func, foundUI, foundNumIndex);
            end;
        end;
        local protos = debug.getprotos(func);
        for i, proto in pairs(protos) do
            deepScan(proto, path .. " > Proto" .. i);
        end;
    end;
    for _, func in pairs(getgc()) do
        if type(func) == "function" and islclosure(func) and (not isexecutorclosure(func)) then
            local info = debug.getinfo(func);
            if info.source and string.find(info.source, "AutoReconnect.c") then
                deepScan(func, "Main");
            end;
        end;
    end;
    local VirtualUser = game:GetService("VirtualUser");
    (game:GetService("Players")).LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController();
        VirtualUser:ClickButton2(Vector2.new());
    end);
end;
task.spawn(InitAutoReconnectBypass);

-- [MODULE LOADING SECTION]
local ConfigsPath = ReplicatedStorage.Scripts.Configs;
local YenModule = require(ConfigsPath.Machines.YenUpgrades);
local TokenModule = require(ConfigsPath.Machines.TokenUpgrades);
local RankModule = require(ConfigsPath.Machines.RankUp);
local UtilsModule = require(ConfigsPath.Utility.Utils);
local MaterialsModule = require(ConfigsPath.General.Materials);

-- [MODIFIKASI BARU: LOAD WEAPONS DATABASE]
local WeaponsModule = {}
pcall(function()
    -- Mengambil data dari MultipleZones/Weapons untuk mendapatkan Template ID senjata
    local MZPath = ConfigsPath:FindFirstChild("MultipleZones") or ConfigsPath:FindFirstChild("Multiple Zones")
    if MZPath and MZPath:FindFirstChild("Weapons") then
        local WeaponsFolder = MZPath.Weapons
        for _, module in pairs(WeaponsFolder:GetChildren()) do
            if module:IsA("ModuleScript") then
                local success, data = pcall(require, module)
                if success and type(data) == "table" then
                    for weaponId, weaponData in pairs(data) do
                        WeaponsModule[weaponId] = weaponData
                    end
                end
            end
        end
    end
end)

-- [LOAD ACCESSORIES DATABASE]
local AccessoriesConfig = {}
pcall(function()
    local AccModuleScript = ConfigsPath:FindFirstChild("MultipleZones") and ConfigsPath.MultipleZones:FindFirstChild("Accessories")
    if AccModuleScript then
        AccessoriesConfig = require(AccModuleScript)
    end
end)

local EnemiesConfig = {}
pcall(function()
    local MZPath = ConfigsPath:FindFirstChild("MultipleZones") or ConfigsPath:FindFirstChild("Multiple Zones")
    if MZPath and MZPath:FindFirstChild("Enemies") then
        EnemiesConfig = require(MZPath.Enemies)
    end
end)

local ChanceModules = {};
local ChancePath = ReplicatedStorage.Scripts.Configs:FindFirstChild("ChanceUpgrades");
if ChancePath then
    for _, name in ipairs(ChanceUpgradeTypes) do
        local s, m = pcall(require, ChancePath:FindFirstChild(name));
        if s and type(m) == "table" then
            ChanceModules[name] = m;
        else
            warn("Failed to load Chance Module: " .. name);
        end;
    end;
end;
local UpgradesModules = {};
do
    local upgradesFolder = ReplicatedStorage.Scripts.Configs:FindFirstChild("RollGachaUpgrades");
    if upgradesFolder then
        for _, m in pairs(upgradesFolder:GetChildren()) do
            if m:IsA("ModuleScript") then
                local s, d = pcall(require, m);
                if s and type(d) == "table" then
                    UpgradesModules[m.Name] = d;
                end;
            end;
        end;
    end;
end
local MagicEyesModule = UpgradesModules["MagicEyes"];
local DemonArtModule = UpgradesModules["DemonArt"];
local YenUpgradeConfig = YenModule.Config;
local TokenUpgradeConfig = TokenModule.Config;
local MaxRankCap = RankModule.MAX or 33;
local function GetYenCost(lvl)
    return YenModule.GetUpgradeCost(lvl);
end;
local function GetYenBuff(name, lvl)
    return YenModule.GetUpgradeBuff(name, lvl);
end;
local function GetTokenCost(lvl,name)
    return TokenModule.GetUpgradeCost(lvl,name);
end;
local function GetTokenBuff(name, lvl)
    return TokenModule.GetUpgradeBuff(name, lvl);
end;
local function GetRankRequirement(rank)
    return RankModule.GetRequirement(rank);
end;
local function GetRankBuff(rank)
    return RankModule.GetBuff(rank);
end;
local function FormatNumber(n)
    return UtilsModule.ToText(n);
end;

local function LoadZoneDB()
    if isfile(FolderPath .. "/" .. ZoneDBFile) then
        local success, result = pcall(function()
            return HttpService:JSONDecode(readfile(FolderPath .. "/" .. ZoneDBFile));
        end);
        if success and type(result) == "table" then
            Config.ZoneConfigurations = result;
        end;
    end;
end;

local function SaveZoneConfig(zone, selectedItem)
    if not zone or zone == "" or zone == "Unknown" then
        return;
    end;
    if not selectedItem then
        return;
    end;
    local val = type(selectedItem) == "table" and selectedItem.Value or selectedItem;
    local title = type(selectedItem) == "table" and selectedItem.Title or selectedItem;
    if not val or val == "" then
        return;
    end;
    local savedEntry = {};
    local foundObj = nil;
    for _, cached in ipairs(CurrentZoneEnemiesCache) do
        if cached.Value == val then
            foundObj = cached;
            break;
        end;
    end;
    if foundObj then
        savedEntry = foundObj;
    else
        savedEntry = {
            Title = title,
            Value = val,
            Desc = "Saved"
        };
    end;
    Config.SelectedEnemy = val;
    Config.ZoneConfigurations[zone] = savedEntry;

    if not isfolder(FolderPath) then
        makefolder(FolderPath);
    end;
    if writefile and HttpService then
        pcall(function()
            writefile(FolderPath .. "/" .. ZoneDBFile, HttpService:JSONEncode(Config.ZoneConfigurations));
        end);
    end;
end;
LoadZoneDB();

local function GetOnlineKeys()
    local keys = {
        "Keynya",
        "FreeKey"
    };
    local url = "https://raw.githubusercontent.com/AdityaNugrahaInside/ANHub/refs/heads/main/Key";
    local success, response = pcall(function()
        return game:HttpGet(url);
    end);
    if success then
        keys = {};
        for line in response:gmatch("[^\r\n]+") do
            local cleanKey = string.gsub(line, "^%s*(.-)%s*$", "%1");
            if cleanKey ~= "" then
                table.insert(keys, cleanKey);
            end;
        end;
    end;
    return keys;
end;
local function GetDynamicRankIcon()
    local iconId = "rbxassetid://84366761557806";
    pcall(function()
        local part = Workspace.Billboards.Machines.RankUp.icon;
        if part and part.Image then
            iconId = part.Image;
        end;
    end);
    return iconId;
end;
local function GetIcon(id)
    return "rbxassetid://" .. tostring(id)
end
local function GetYenIcon()
    local icon = "rbxassetid://84366761557806"
    pcall(function()
        icon = (game:GetService("Players")).LocalPlayer.PlayerGui.Screen.Hud.left.yen.icon.Image;
    end)
    return icon
end
local function GetTrainerIcon()
    local icon = "rbxassetid://10723415903"
    pcall(function()
        icon = (game:GetService("Players")).LocalPlayer.PlayerGui.Screen.Hud.left.buttons.Arsenal.button.icon.Image;
    end)
    return icon
end
-- moved earlier
local function GetRollIconAsset(rollType)
    local fallback = "rbxassetid://84366761557806";
    local assetId = "";
    pcall(function()
        local machine = Workspace.Billboards.CrateRoll:FindFirstChild(rollType);
        if machine and machine:FindFirstChild("icon") then
            assetId = machine.icon.Image;
        end;
    end);
    if assetId == "" or assetId == nil then
        if RollConfigs[rollType] and RollConfigs[rollType].ImageId then
            assetId = RollConfigs[rollType].ImageId;
        end;
    end;
    if assetId and assetId ~= "" then
        local cleanId = ((tostring(assetId)):gsub("rbxassetid://", "")):gsub("http://www.roblox.com/asset/%?id=", "");
        if tonumber(cleanId) then
            return "rbxassetid://" .. cleanId;
        else
            return assetId;
        end;
    end;
    return fallback;
end;
local dungeonList, dungeonDB, raidList, raidDB = {}, {}, {}, {};
local defenseList, defenseDB = {}, {};
local function LoadDungeonData()
    local success, module = pcall(function()
        return require(ReplicatedStorage.Scripts.Configs.Gamemodes.Dungeon);
    end);
    if success and module and module.PHASES then
        dungeonList, dungeonDB = {}, {};
        for id, phase in ipairs(module.PHASES) do
            local dName = phase.Name;
            local hpCalc = math.floor((phase.HealthBase or 0) / 50);
            local desc = "Hp Base: " .. FormatNumber(hpCalc);
            table.insert(dungeonList, {
                Title = dName,
                Desc = desc,
                Value = dName
            });
            dungeonDB[dName] = {
                ID = id,
                Time = phase.START_MINUTE,
                BaseDesc = desc
            };
        end;
    end;
end;
local function LoadRaidData()
    local success, module = pcall(function()
        return require(ReplicatedStorage.Scripts.Configs.Gamemodes.Raid);
    end);
    if success and module and module.PHASES then
        raidList, raidDB = {}, {};
        for id, phase in ipairs(module.PHASES) do
            local rName = phase.Name;
            local hpCalc = math.floor((phase.HealthBase or 0) / 50);
            local desc = "Hp Base: " .. FormatNumber(hpCalc);
            table.insert(raidList, {
                Title = rName,
                Desc = desc,
                Value = rName
            });
            raidDB[rName] = {
                ID = id,
                Times = phase.START_TIMES,
                BaseDesc = desc
            };
        end;
    end;
end;
local function LoadDefenseData()
    local success, module = pcall(function()
        return require(ReplicatedStorage.Scripts.Configs.Gamemodes.Defense);
    end);
    if success and module and module.PHASES then
        defenseList, defenseDB = {}, {};
        for id, phase in ipairs(module.PHASES) do
            local rName = phase.Name;
            local hpCalc = math.floor((phase.HealthBase or 0) / 50);
            local desc = "Hp Base: " .. FormatNumber(hpCalc);
            table.insert(defenseList, {
                Title = rName,
                Desc = desc,
                Value = rName
            });
            defenseDB[rName] = {
                ID = id,
                Times = phase.START_TIMES,
                BaseDesc = desc
            };
        end;
    end;
end;
local function LoadRollData(rollType)
    local success, module = pcall(function()
        return require(ReplicatedStorage.Scripts.Configs.RollGachas[rollType]);
    end);
    if success and module then
        RollConfigs[rollType] = {
            Cost = module.Cost or 1,
            MaterialKey = module.Material or rollType .. "Token",
            ImageId = module.ImageId
        };
    else
        local up = UpgradesModules and UpgradesModules[rollType];
        if up then
            RollConfigs[rollType] = {
                Cost = up.Cost or 1,
                MaterialKey = up.Material or rollType .. "Token",
                ImageId = up.ImageId
            };
        else
            RollConfigs[rollType] = {
                Cost = 1,
                MaterialKey = rollType .. "Token",
                ImageId = "84366761557806"
            };
        end;
    end;
end;
LoadDungeonData();
LoadRaidData();
LoadDefenseData();
for _, rollType in ipairs(AllRollTypes) do
    LoadRollData(rollType);
end;

-- [MODIFIKASI BARU: Helper Function untuk Mendapatkan Icon dari ChanceReward]
local function GetRewardAssetId(rewardKey)
    if not rewardKey then return nil end
    -- Kunci bisa berupa "Weapons.WildKatana" atau "Materials.BreathingToken.5"
    local parts = string.split(rewardKey, ".")
    local typeCategory = parts[1] -- "Weapons" atau "Materials"
    local itemName = parts[2] -- "WildKatana" atau "BreathingToken"

    local templateId = nil

    if typeCategory == "Materials" and MaterialsModule[itemName] then
        templateId = MaterialsModule[itemName].Template
    elseif typeCategory == "Weapons" and WeaponsModule[itemName] then
        templateId = WeaponsModule[itemName].Template
    end

    if templateId then
        -- Format Asset ID
        local idStr = tostring(templateId)
        if not idStr:find("rbxassetid://") then
            return "rbxassetid://" .. idStr
        else
            return idStr
        end
    end
    return nil
end

-- [HELPER: GET OWNED ACCESSORIES LIST (WITH ICON)]
local function GetOwnedAccessories()
    local list = {}
    local pData = getgenv().PlayerData
    if pData and pData.Accessories then
        for id, owned in pairs(pData.Accessories) do
            if owned == true then
                local info = AccessoriesConfig[id]
                local displayName = info and info.Display or id
                
                -- [FEATURE: FETCH IMAGE FROM TEMPLATE]
                local imageId = "rbxassetid://84366761557806" -- Default placeholder
                if info and info.Template then
                    imageId = "rbxassetid://" .. tostring(info.Template)
                end
                
                table.insert(list, {
                    Title = displayName,
                    Value = id, -- Internal Name
                    Icon = imageId, -- FIX: Gunakan Key 'Icon' agar gambar muncul (sama kayak Select Token)
                    Desc = info and info.Rarity or "Accessory"
                })
            end
        end
    end
    table.sort(list, function(a,b) return a.Title < b.Title end)
    return list
end

local function FireAccessory(accName)
    if Reliable then
        pcall(function()
            Reliable:FireServer("Accessory Equip", {accName})
        end)
    end
end

-- [MODIFIKASI BARU: UPDATE RefreshEnemyData]
local function RefreshEnemyData()
    local uiList = {}
    if EnemiesConfig and CurrentZoneName and CurrentZoneName ~= "" and CurrentZoneName ~= "Unknown" then
        local added = {}
        for key, data in pairs(EnemiesConfig) do
            if data.Zone == CurrentZoneName then
                local displayName = data.Display or key
                if not added[displayName] then
                    added[displayName] = true
                    local rewardImages = {}
                    if data.ChanceReward then
                        for rewardKey, _ in pairs(data.ChanceReward) do
                            local img = GetRewardAssetId(rewardKey)
                            if img then table.insert(rewardImages, img) end
                        end
                    end
                    table.sort(rewardImages)
                    table.insert(uiList, {
                        Title = displayName .. " (" .. (data.Difficult or "Normal") .. ")",
                        Value = displayName,
                        Desc = "HP: " .. FormatNumber((data.MaxHealth or 0)),
                        HP = data.MaxHealth or 0,
                        Images = rewardImages
                    })
                end
            end
        end
    end
    table.sort(uiList, function(a, b) return a.HP < b.HP end)
    CurrentZoneEnemiesCache = uiList
    return uiList
end

local function UpdateLiveEnemies()
    local newMap = {}
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" then
            local rawConfig = rawget(v, "Config")
            local alive = rawget(v, "Alive")
            local data = rawget(v, "Data")
            if rawConfig and alive == true and data and data.CFrame then
                local keyName = rawConfig.Display or (v.Character and v.Character.Name) or "Unknown"
                if not newMap[keyName] then newMap[keyName] = {} end
                table.insert(newMap[keyName], v)
            end
        end
    end
    GlobalEnemyMap = newMap
end



local l = loadstring(game:HttpGet("https://raw.githubusercontent.com/ANHub-Script/ANUI/refs/heads/main/dist/main.lua?v="..math.random()))();

local Window = l:CreateWindow({
    Title = "AN Hub - Anime Weapons",
    Icon = "rbxassetid://84366761557806",
    Author = "Aditya Nugraha",
    Folder = "AnimeWeapons",
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 220,
    HideSearchBar = true,
    ToggleKey = Enum.KeyCode.RightControl,
    KeySystem = {
        Enabled = true,
        Title = "ANHub Access",
        Description = "Key expires every 24 Hours!",
        Key = GetOnlineKeys(),
        URL = "https://discord.gg/cy6uMRmeZ",
        Note = "Join Discord for Key",
        SaveKey = true
    }
});

task.delay(1.0, function()
    Window:CollapseSidebar()
end)

task.delay(3.0, function()
    Window:ExpandSidebar()
end)
task.spawn(function()
    task.wait(1)
    while Window and not Window.Destroyed do
        if Config.AutoFarm or (Window and not Window.Closed) then
            pcall(UpdateLiveEnemies)
        end
        task.wait(1)
    end
end)

local function Notify(title, content, icon)
	if l then l:Notify({ Title = title, Content = content, Icon = icon, Duration = 3 }) end
end

local BaseProfile = {
	Banner = "rbxassetid://124762019485618", Avatar = "rbxassetid://84366761557806", Status = true,
	Badges = {
		{
			Icon = "geist:logo-discord", Title = "Discord", Desc = "Join ANHUB Discord",
			Callback = function() setclipboard("https://discord.gg/cy6uMRmeZ") Notify("Discord", "Invite link copied to clipboard!", "geist:logo-discord") end
		},
		{
			Icon = "youtube", Desc = "Subscribe to YouTube",
			Callback = function() setclipboard("https://www.youtube.com/@ANHubRoblox") Notify("YouTube", "Channel link copied!", "youtube") end
		}
	}
}

local function MakeProfile(data)
	local p = table.clone(BaseProfile)
	for k, v in pairs(data or {}) do p[k] = v end
	return p
end

Window:Tab({
	Profile = MakeProfile({ Title = "ANHub Script", Desc = "Anime Eternal",
    Badges = {
		{
			Icon = "geist:logo-discord", Desc = "Join ANHUB Discord",
			Callback = function() setclipboard("https://discord.gg/cy6uMRmeZ") Notify("Discord", "Invite link copied to clipboard!", "geist:logo-discord") end
		},
		{
			Icon = "youtube", Desc = "Subscribe to YouTube",
			Callback = function() setclipboard("https://www.youtube.com/@ANHubRoblox") Notify("YouTube", "Channel link copied!", "youtube") end
		}
	} }),
	SidebarProfile = true
})

do
    Window:Tag({
        Title = "v" .. ANUI.Version,
        Icon = "github",
        Color = Color3.fromHex("#ff0000")
    });
end;

if not isfile(ExpiryFile) then
    writefile(ExpiryFile, tostring(os.time() + 86400));
end;

Window:OnDestroy(function()
    Config.AutoFarm = false;
    Config.AutoDungeon = false;
    Config.AutoFuse = false;
    Config.AutoRankUp = false;
    Config.AutoRollBiju = false;
    Config.AutoRollRace = false;
    Config.AutoRollSayajin = false;
    Config.AutoYen_Luck = false;
    Config.AutoYen_Damage = false;
    Config.AutoYen_Yen = false;
    Config.AutoYen_Mastery = false;
    Config.AutoYen_Critical = false;
    if CurrentZoneName ~= "" and Config.SelectedEnemy then
        SaveZoneConfig(CurrentZoneName, Config.SelectedEnemy);
    end;
end);

local function CreateTabButtons(section, tabNames)
    local TabSystem = {
        CurrentTab = tabNames[1],
        Elements = {},
        ButtonObjects = {}
    }
    for _, name in pairs(tabNames) do TabSystem.Elements[name] = {} end

    local ButtonContainer = Instance.new("Frame")
    ButtonContainer.Name = "TabButtonsContainer"
    ButtonContainer.Size = UDim2.new(1, 0, 0, 35)
    ButtonContainer.BackgroundTransparency = 1

    local ContainerPadding = Instance.new("UIPadding")
    ContainerPadding.Parent = ButtonContainer
    ContainerPadding.PaddingLeft = UDim.new(0, 5)
    ContainerPadding.PaddingRight = UDim.new(0, 5)

    local Dummy = section:Paragraph({Title="Temp", Desc=""})
    local ContentParent = Dummy.ParagraphFrame.UIElements.Main.Parent.Parent.Content
    ButtonContainer.Parent = ContentParent
    Dummy.ParagraphFrame:Destroy()

    ButtonContainer.LayoutOrder = -9999

    local UIList = Instance.new("UIListLayout")
    UIList.Parent = ButtonContainer
    UIList.FillDirection = Enum.FillDirection.Horizontal
    UIList.SortOrder = Enum.SortOrder.LayoutOrder
    UIList.Padding = UDim.new(0, 5)

    local function UpdateVisibility(selectedTab)
        TabSystem.CurrentTab = selectedTab
        for name, objects in pairs(TabSystem.Elements) do
            local isVisible = (name == selectedTab)
            for _, obj in ipairs(objects) do
                if obj.ElementFrame then
                    obj.ElementFrame.Visible = isVisible
                elseif obj.UIElements and obj.UIElements.Main then
                    obj.UIElements.Main.Visible = isVisible
                elseif obj.GroupFrame then
                    obj.GroupFrame.Visible = isVisible
                end
            end
        end
        for name, btn in pairs(TabSystem.ButtonObjects) do
            local isSelected = (name == selectedTab)
            local targetColor = isSelected and Color3.fromRGB(60, 200, 120) or Color3.fromRGB(45, 45, 45)
            local targetText = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180)
            game:GetService("TweenService"):Create(btn, TweenInfo.new(0.2), {BackgroundColor3 = targetColor}):Play()
            game:GetService("TweenService"):Create(btn.TextLabel, TweenInfo.new(0.2), {TextColor3 = targetText}):Play()
        end
        task.spawn(function()
            task.wait(0.05)
            if section.Opened then
                section:Open()
            end
        end)
    end

    local btnWidth = 1 / #tabNames

    for i, name in ipairs(tabNames) do
        local btn = Instance.new("TextButton")
        btn.Name = name .. "_Btn"
        btn.Parent = ButtonContainer
        btn.Size = UDim2.new(btnWidth, -5, 1, 0)
        btn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        btn.AutoButtonColor = true
        btn.Text = ""

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = btn

        local lbl = Instance.new("TextLabel")
        lbl.Parent = btn
        lbl.Size = UDim2.new(1,0,1,0)
        lbl.BackgroundTransparency = 1
        lbl.Text = name
        lbl.Font = Enum.Font.GothamBold
        lbl.TextSize = 12
        lbl.TextColor3 = Color3.fromRGB(180, 180, 180)

        btn.MouseButton1Click:Connect(function() UpdateVisibility(name) end)
        TabSystem.ButtonObjects[name] = btn
    end

    function TabSystem:Add(tabName, elementObject)
        if not TabSystem.Elements[tabName] then return end
        table.insert(TabSystem.Elements[tabName], elementObject)
        if tabName ~= TabSystem.CurrentTab then
            if elementObject.ElementFrame then
                elementObject.ElementFrame.Visible = false
            elseif elementObject.UIElements and elementObject.UIElements.Main then
                elementObject.UIElements.Main.Visible = false
            elseif elementObject.GroupFrame then
                elementObject.GroupFrame.Visible = false
            end
        end
    end

    UpdateVisibility(tabNames[1])
    section:Divider()
    return TabSystem
end
local function GetHRP()
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart");
end;
LocalPlayer.CharacterAdded:Connect(function(char)
    hrp = char:WaitForChild("HumanoidRootPart");
    humanoid = char:WaitForChild("Humanoid");
end);
pcall(function()
    if LocalPlayer.Character then
        hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart");
        humanoid = LocalPlayer.Character:FindFirstChild("Humanoid");
    end;
end);
local function LogicAutoFarm()
    local currentTargetObj = nil
    while Config.AutoFarm do
        if Window.Destroyed then break end
        if not hrp or not hrp.Parent or not humanoid or humanoid.Health <= 0 then
            currentTargetObj = nil
            task.wait(1)
            if LocalPlayer.Character then
                hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            end
        else
            if currentTargetObj then
                if currentTargetObj.Alive == false or (not currentTargetObj.Data) or (not currentTargetObj.Uid) or (not currentTargetObj.Parent) then
                    currentTargetObj = nil
                end
            end
            if not currentTargetObj then
                local targetName = Config.SelectedEnemy
                if targetName and GlobalEnemyMap[targetName] then
                    local enemyList = GlobalEnemyMap[targetName]
                    local closest, minDst = nil, math.huge
                    local myPos = hrp.Position
                    for _, enemyObj in ipairs(enemyList) do
                        if enemyObj.Alive == true and enemyObj.Data and enemyObj.Data.CFrame then
                            local dst = (myPos - enemyObj.Data.CFrame.Position).Magnitude
                            if dst < minDst then
                                minDst = dst
                                closest = enemyObj
                            end
                        end
                    end
                    if closest then
                        currentTargetObj = closest
                    end
                end
            end
            if currentTargetObj and currentTargetObj.Data and currentTargetObj.Data.CFrame then
                pcall(function()
                    hrp.CFrame = currentTargetObj.Data.CFrame * CFrame.new(0, 5, 2)
                end)
            end
        end
        task.wait()
    end
end
local function MaintainAutoStatus()
    while not Window.Destroyed do
        if Config.AutoFarm or Config.AutoDungeon then
            local Data = (getgenv()).PlayerData;
            if Data and Data.Settings and Reliable then
                if Data.Settings.AutoClick == false then
                    pcall(function()
                        Reliable:FireServer("Settings", {
                            "AutoClick",
                            true
                        });
                    end);
                end;
                if Data.Settings.AutoAttack == false then
                    pcall(function()
                        Reliable:FireServer("Settings", {
                            "AutoAttack",
                            true
                        });
                    end);
                end;
            end;
        end;
        task.wait(1);
    end;
end;
local function isPlayerInZone(zone)
    local chars = zone:FindFirstChild("Characters");
    if chars and chars:FindFirstChild(LocalPlayer.Name) then
        return true;
    end;
    return false;
end;
local function GetCurrentMapStatus()
    local zones = Workspace:FindFirstChild("Zones");
    if zones then
        for _, zone in pairs(zones:GetChildren()) do
            if isPlayerInZone(zone) then
                return zone.Name;
            end;
        end;
    end;
    if Workspace:FindFirstChild("Dungeon") then
        return "Dungeon";
    end;
    if Workspace:FindFirstChild("Raid") then
        return "Raid";
    end;
    if Workspace:FindFirstChild("Defense") then
        return "Defense";
    end;
    if Workspace:FindFirstChild("Enemies") and (not zones) then
        return "Dungeon:Active";
    end;
    return "Unknown";
end;

task.spawn(function()
    local EnemiesFolder = Workspace:WaitForChild("Enemies", 5)
    if EnemiesFolder then
        local Debounce = false
        local function TriggerRefresh()
            if Debounce then return end

            local currentMap = GetCurrentMapStatus()
            local isGamemode = string.find(currentMap, "Dungeon") or string.find(currentMap, "Raid") or string.find(currentMap, "Defense")

            if not isGamemode then
                return
            end

            Debounce = true
            task.wait(1.5)
            RefreshEnemyData()
            Debounce = false
        end

        EnemiesFolder.ChildAdded:Connect(TriggerRefresh)
        EnemiesFolder.ChildRemoved:Connect(TriggerRefresh)
    end
end);

-- [MODIFICATION: Yehe.lua Wave Detection Logic]
local waveRaid = 0; local waveDungeon = 0; local waveDef = 0; local waveShadow = 0;
local function SetupWaveDetection()
    local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui", 10)
    if not PlayerGui then return end
    
    local function safeConnect(pathTable, callback)
        local obj = PlayerGui
        for _, name in ipairs(pathTable) do
             obj = obj:WaitForChild(name, 5)
             if not obj then return end
        end
        
        if obj:IsA("TextLabel") or obj:IsA("TextButton") then
            pcall(function() callback(obj.Text) end) -- Initial check
            obj:GetPropertyChangedSignal("Text"):Connect(function()
                pcall(function() callback(obj.Text) end)
            end)
        end
    end

    task.spawn(function()
        safeConnect({"Screen", "Hud", "gamemode", "Dungeon", "room", "amount"}, function(txt)
            waveDungeon = tonumber((string.gsub(txt, "Room: ", ""))) or 0
        end)
    end)
    task.spawn(function()
        safeConnect({"Screen", "Hud", "gamemode", "Raid", "wave", "amount"}, function(txt)
            local val = tonumber((string.gsub(txt, "Room: ", "")))
            if not val then val = tonumber((string.gsub(txt, "Wave: ", ""))) end
            waveRaid = val or 0
        end)
    end)
    task.spawn(function()
        safeConnect({"Screen", "Hud", "gamemode", "Defense", "wave", "amount"}, function(txt)
            local val = tonumber((string.gsub(txt, "Room: ", "")))
            if not val then val = tonumber((string.gsub(txt, "Wave: ", ""))) end
            waveDef = val or 0
        end)
    end)
    task.spawn(function()
        safeConnect({"Screen", "Hud", "gamemode", "ShadowGate", "wave", "amount"}, function(txt)
            local val = tonumber((string.gsub(txt, "Room: ", "")))
            if not val then val = tonumber((string.gsub(txt, "Wave: ", ""))) end
            waveShadow = val or 0
        end)
    end)
end
task.spawn(SetupWaveDetection)

local function IsInGamemode()
    if Workspace:FindFirstChild("Dungeon") then return true end
    if Workspace:FindFirstChild("Raid") then return true end
    if Workspace:FindFirstChild("Defense") then return true end
    return false
end

local function IsInLobbyZone()
    if Workspace:FindFirstChild("Zones") and Workspace.Zones:FindFirstChild("Dungeon") then
        if isPlayerInZone(Workspace.Zones.Dungeon) then
            return true
        end
    end
    return false
end

task.spawn(function()
    while not Window.Destroyed do
        local zones = Workspace:FindFirstChild("Zones")
        if not zones or dontTeleport then
            task.wait(6)
            continue
        end
        local target = LastZone
        if not target or target == "" or target == "Unknown" then
            task.wait(6)
            continue
        end
        local targetZone = zones:FindFirstChild(target)
        local inTarget = false
        if targetZone and isPlayerInZone(targetZone) then
            inTarget = true
        end
        if inTarget or IsInGamemode() or IsInLobbyZone() or (not HasJoinedGamemode) then
            task.wait(6)
            continue
        end
        if Reliable then
            pcall(function()
                Reliable:FireServer("Zone Teleport", { target })
            end)
        end
        task.wait(6)
    end
end)

local function LogicGamemodes()
    local wasInGamemode = false;
    local currentTargetObj = nil;
    local refreshTimer = 0;
    local lastTeleportedUid = nil;
    local hasTeleportedToBossInRaid = false;
    local LastAccessoryState = "None"

    while Config.AutoDungeon or Config.AutoEquipAccessories do
        if Window.Destroyed then
            break;
        end;
        local currentMap = GetCurrentMapStatus();
        local inLobbyZone = false;
        if Workspace:FindFirstChild("Zones") and Workspace.Zones:FindFirstChild("Dungeon") then
            if isPlayerInZone(Workspace.Zones.Dungeon) then
                inLobbyZone = true;
            end;
        end;
        local EnemiesFolder = Workspace:FindFirstChild("Enemies")
        local hasEnemies = EnemiesFolder and #EnemiesFolder:GetChildren() > 0
        local isFightingZone = string.find(currentMap, ":") and (string.find(currentMap, "Dungeon") or string.find(currentMap, "Raid") or string.find(currentMap, "Defense"));
        if currentMap == "Raid" then
            isFightingZone = true
        elseif currentMap == "Defense" then
            isFightingZone = hasEnemies
        end

        -- [LOGIC: AUTO EQUIP ACCESSORIES]
        if Config.AutoEquipAccessories then
            if isFightingZone then
                -- Kita sedang di mode tempur
                if LastAccessoryState ~= "InMode" and Config.AccessoryInMode then
                    FireAccessory(Config.AccessoryInMode)
                    LastAccessoryState = "InMode"
                end
            else
                -- Kita di lobby
                if LastAccessoryState ~= "OutMode" and Config.AccessoryOutMode then
                    FireAccessory(Config.AccessoryOutMode)
                    LastAccessoryState = "OutMode"
                end
            end
        end

        if not Config.AutoDungeon then
            task.wait(1)
            continue
        end

        if currentMap ~= "Unknown" then
            if isFightingZone then
                wasInGamemode = true;
                dontTeleport = true

                local exceedWave = false
                if string.find(currentMap, "Raid") and waveRaid > (Config.TargetWaveRaid or 500) then exceedWave = true end
                if string.find(currentMap, "Defense") and waveDef > (Config.TargetWaveDef or 500) then exceedWave = true end
                if string.find(currentMap, "Dungeon") and waveDungeon > (Config.TargetWaveDungeon or 500) then exceedWave = true end

                if exceedWave and LastZone and LastZone ~= "" and LastZone ~= "Unknown" then
                    if Reliable then
                        pcall(function()
                            Reliable:FireServer("Zone Teleport", { LastZone });
                        end)
                    end
                    currentTargetObj = nil
                    task.wait(2)
                    continue
                end

                if os.time() - refreshTimer > 10 then
                    RefreshEnemyData();
                    refreshTimer = os.time();
                end;
                if currentTargetObj then
                    if currentTargetObj.Alive == false or (not currentTargetObj.Data) then
                        currentTargetObj = nil;
                    end;
                end;

                local isRaid = string.find(currentMap, "Raid")
                local isDefense = string.find(currentMap, "Defense")

                if not currentTargetObj and hrp then
                    local closest, minDst = nil, math.huge;
                    local myPos = hrp.Position;
                    local bossFound = false

                    for _, enemyList in pairs(GlobalEnemyMap) do
                        for _, enemyObj in ipairs(enemyList) do
                            if enemyObj.Alive == true and enemyObj.Data and enemyObj.Data.CFrame then
                                local dst = (myPos - enemyObj.Data.CFrame.Position).Magnitude;
                                local config = rawget(enemyObj, "Config")
                                local isBoss = config and config.Difficult == "Emperor"

                                if isRaid and isBoss then
                                    closest = enemyObj
                                    bossFound = true
                                    break
                                end

                                if dst < minDst then
                                    minDst = dst;
                                    if not bossFound then
                                        closest = enemyObj;
                                    end
                                end;
                            end;
                        end;
                        if bossFound then break end
                    end;

                    if closest then
                        currentTargetObj = closest;
                        if currentTargetObj.Data and currentTargetObj.Data.CFrame then
                            local config = rawget(currentTargetObj, "Config")
                            local isBoss = config and config.Difficult == "Emperor"
                            local targetUid = currentTargetObj.Uid

                            if isRaid then
                                if isBoss and (not hasTeleportedToBossInRaid) then
                                    hrp.CFrame = currentTargetObj.Data.CFrame * CFrame.new(0, 5, 2);
                                    hasTeleportedToBossInRaid = true;
                                end
                            else
                                hrp.CFrame = currentTargetObj.Data.CFrame * CFrame.new(0, 5, 2);
                                lastTeleportedUid = targetUid
                            end
                        end;
                    end;
                end;
                task.wait(0.1);
            elseif inLobbyZone or wasInGamemode and (not isFightingZone) then
                currentTargetObj = nil;
                lastTeleportedUid = nil;
                hasTeleportedToBossInRaid = false;
                dontTeleport = false
                wasInGamemode = false;
            else
                local t = os.date("*t");
                local currentMinute = t.min;
                local targetString, targetName = nil, "";
                for _, dName in pairs(Config.TargetDungeon) do
                    local data = dungeonDB[dName];
                    if data and currentMinute == data.Time then
                        targetString = "Dungeon:" .. tostring(data.ID);
                        targetName = dName;
                        break;
                    end;
                end;
                if not targetString then
                    for _, rName in pairs(Config.TargetRaid) do
                        local data = raidDB[rName];
                        if data and data.Times then
                            for _, timeVal in ipairs(data.Times) do
                                if currentMinute == timeVal then
                                    targetString = "Raid:" .. tostring(data.ID);
                                    targetName = rName;
                                    break;
                                end;
                            end;
                        end;
                        if targetString then
                            break;
                        end;
                    end;
                end;
                if not targetString then
                    for _, dName in pairs(Config.TargetDefense) do
                        local data = defenseDB[dName];
                        if data and data.Times then
                            for _, timeVal in ipairs(data.Times) do
                                if currentMinute == timeVal then
                                    targetString = "Defense:" .. tostring(data.ID);
                                    targetName = dName;
                                    break;
                                end;
                            end;
                        end;
                        if targetString then
                            break;
                        end;
                    end;
                end;

                if targetString then
                    if not string.find(currentMap, "Dungeon:") and (not string.find(currentMap, "Raid:")) and (not string.find(currentMap, "Defense:")) then
                        LastZone = currentMap;
                    end;
                    l:Notify({
                        Title = "Auto Mode",
                        Content = "Joining " .. targetName,
                        Icon = "swords",
                        Duration = 2
                    });
                    if Reliable then
                        pcall(function()
                            Reliable:FireServer("Join Gamemode", {
                                targetString
                            });
                        end);
                    end;
                    HasJoinedGamemode = true
                    task.wait(5);
                end;
                task.wait(1);
            end;
        else
            task.wait(1);
        end;
    end;
end;
task.spawn(function()
    while not Window.Destroyed do
        local anyRollActive = false;
        for _, rollType in ipairs(AllRollTypes) do
            if Config["AutoRoll" .. rollType] then
                anyRollActive = true;
                if Reliable then
                    pcall(function()
                        Reliable:FireServer("Crate Roll Start", {
                            rollType,
                            false
                        });
                    end);
                end;
                task.wait(1.5);
            end;
        end;
        if not anyRollActive then
            task.wait(1);
        end;
    end;
end);
task.spawn(function()
    local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui");
    local prevRolling = false;
    while not Window.Destroyed do
        local isRolling = false;
        for _, rType in ipairs(AllRollTypes) do
            if Config["AutoRoll" .. rType] then
                isRolling = true;
                break;
            end;
        end;
        if isRolling ~= prevRolling then
            prevRolling = isRolling;
            if isRolling then
                local CrateUI = PlayerGui:FindFirstChild("Crate");
                if CrateUI then
                    CrateUI.Parent = nil;
                end;
                local ScreenUI = PlayerGui:FindFirstChild("Screen");
                if ScreenUI and (not ScreenUI.Enabled) then
                    ScreenUI.Enabled = true;
                end;
                local Topbar = PlayerGui:FindFirstChild("TopbarStandard");
                if Topbar and (not Topbar.Enabled) then
                    Topbar.Enabled = true;
                end;
            end;
        end;
        task.wait(1);
    end;
end);
local InfoTab = Window:Tab({
    Title = "Info",
    Icon = "info"
});
local s, tUrl = pcall(function()
    return Players:GetUserThumbnailAsync(LocalPlayer.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size150x150);
end);
local PlayerParagraph = InfoTab:Paragraph({
    Title = LocalPlayer.DisplayName,
    Desc = "User ID: " .. tostring(LocalPlayer.UserId) .. "\nKey Valid: Verifying...",
    Image = s and tUrl or "rbxassetid://84366761557806",
    ImageSize = 48,
    Buttons = {
        {
            Title = "Copy HWID",
            Icon = "copy",
            Callback = function()
                setclipboard(tostring(gethwid and gethwid() or LocalPlayer.UserId));
            end
        }
    }
});
task.spawn(function()
    while not Window.Destroyed do
        local success, result = pcall(function()
            if isfile(ExpiryFile) then
                return tonumber(readfile(ExpiryFile)) or 0;
            end;
            return 0;
        end);
        local statusText = "Checking...";
        if success and result > 0 then
            local diff = result - os.time();
            if diff > 0 then
                local h = math.floor(diff / 3600);
                local m = math.floor(diff % 3600 / 60);
                statusText = string.format("%02dh %02dm", h, m);
            else
                statusText = "EXPIRED";
            end;
        else
            statusText = "No Timer";
        end;
        if PlayerParagraph and PlayerParagraph.SetDesc then
            pcall(function()
                PlayerParagraph:SetDesc("User ID: " .. tostring(LocalPlayer.UserId) .. "\nKey Valid: " .. statusText);
            end);
        end;
        task.wait(1);
    end;
end);
local CommunitySection = InfoTab:Section({
    Title = "Community",
    Icon = "users",
    Opened = true
});
local DiscordInfo = InfoTab:Paragraph({
    Title = "Loading...",
    Desc = "...",
    Image = "rbxassetid://84366761557806",
    ImageSize = 42,
    Buttons = {
        {
            Title = "Copy Discord",
            Icon = "copy",
            Callback = function()
                setclipboard("https://discord.gg/cy6uMRmeZ");
            end
        }
    }
});
task.spawn(function()
    local API = "https://discord.com/api/v10/invites/cy6uMRmeZ?with_counts=true&with_expiration=true";
    local s, r = pcall(function()
        return HttpService:JSONDecode((l.Creator.Request({
            Url = API,
            Method = "GET"
        })).Body);
    end);
    if s and r and r.guild then
        DiscordInfo:SetTitle(r.guild.name);
        DiscordInfo:SetDesc("Members: " .. r.approximate_member_count .. "\nOnline: " .. r.approximate_presence_count);
    else
        DiscordInfo:SetTitle("Discord Error");
        DiscordInfo:SetDesc("Failed to fetch info.");
    end;
end);

local FarmTab = Window:Tab({
    Title = "Main Feature",
    Icon = "swords",
		Profile = MakeProfile({
			Title = "Main Feature",
			Desc = "Anime Weapons"
		}),
		
		SidebarProfile = false -- Mode Tab Biasa
});

local FM_Categories = {}
local function FM_GetElementFrame(elem)
    local f = rawget(elem, "ElementFrame") or (elem.UIElements and elem.UIElements.Main) or rawget(elem, "GroupFrame")
    return f
end
local function FM_Add(cat, elem)
    if not FM_Categories[cat] then FM_Categories[cat] = {} end
    table.insert(FM_Categories[cat], elem)
    local frame = FM_GetElementFrame(elem)
    if frame then frame.Visible = false end
    return elem
end
local function FM_OnChange(selected)
    for name, elems in pairs(FM_Categories) do
        local vis = (name == selected)
        for _, e in ipairs(elems) do
            local f = FM_GetElementFrame(e)
            if f then f.Visible = vis end
        end
    end
end
local FM_Category = FarmTab:Category({
    Title = "Select Category",
    Default = "Zone Farming",
    Options = {
        {Title="Zone Farming", Icon="swords"},
        {Title="Gamemodes", Icon="activity"},
        {Title="Accessories", Icon="package"},
        {Title="Exchange", Icon=GetIcon(TradeTokenInfo.Template)},
        {Title="Crate Roll", Icon="package"},
        {Title="Upgrade: Yen", Icon=GetYenIcon()},
        {Title="Upgrade: Token", Icon="rbxassetid://124644932563791"},
        {Title="Upgrade: Rank", Icon=GetDynamicRankIcon()},
        {Title="Upgrade: Trainer", Icon=GetTrainerIcon()}
    },
    Callback = FM_OnChange
})
FarmTab:Space({Columns=1})

-- [MODIFIKASI: DROPDOWN UNTUK ENEMIES DENGAN IMAGES]
EnemyDropdown = FarmTab:Dropdown({
    Title = "Select Enemy",
    Multi = false,
    Values = {},
    ImageSize = UDim2.fromOffset(20, 20), -- Mengatur ukuran gambar
    ImagePadding = 6, -- Jarak antar gambar
    Flag = "TargetEnemies_Cfg",
    Callback = function(selectedItem)
        if IsLoadingConfig then
            return;
        end;
        SaveZoneConfig(CurrentZoneName, selectedItem);
    end
});
FM_Add("Zone Farming", EnemyDropdown);
local RefreshBtn = FarmTab:Button({
    Title = "Refresh List",
    Icon = "refresh-cw",
    Callback = function()
        EnemyDropdown:Refresh(RefreshEnemyData());
    end
});
FM_Add("Zone Farming", RefreshBtn);
local FarmToggle = FarmTab:Toggle({
    Title = "Auto Farm",
    Flag = "AutoFarm_Cfg",
    Callback = function(val)
        Config.AutoFarm = val;
        if val then
            task.spawn(LogicAutoFarm);
        end;
    end
});
FM_Add("Zone Farming", FarmToggle);
local DgnDrop = FarmTab:Dropdown({
    Title = "Select Dungeon",
    Multi = true,
    AllowNone = true,
    Flag = "DungeonDiff_Cfg",
    Values = dungeonList,
    Callback = function(val)
        local t = {};
        for _, v in pairs(val) do
            table.insert(t, type(v) == "table" and v.Value or v);
        end;
        Config.TargetDungeon = t;
    end
});
FM_Add("Gamemodes", DgnDrop);

task.spawn(function()
    while not Window.Destroyed do
        local t = os.date("*t");
        local currentTotalSeconds = t.min * 60 + t.sec;
        local newList = {};

        for _, item in ipairs(dungeonList) do
            local dName = item.Value;
            local data = dungeonDB[dName];
            if data then
                local startMin = data.Time;
                local startTotalSeconds = startMin * 60;
                local diff = startTotalSeconds - currentTotalSeconds;
                if diff < 0 then
                    diff = diff + 3600;
                end;
                local m = math.floor(diff / 60);
                local s = diff % 60;
                local timeStr = string.format("%02d:%02d", m, s);

                table.insert(newList, {
                    Title = item.Title,
                    Value = item.Value,
                    Desc = data.BaseDesc .. " | Starts in: " .. timeStr
                });
            else
                table.insert(newList, item);
            end;
        end;

        if DgnDrop and DgnDrop.Refresh then
            pcall(function()
                DgnDrop:Refresh(newList);
            end);
        end;
        task.wait(1);
    end;
end);
local RaidDrop = FarmTab:Dropdown({
    Title = "Select Raid",
    Multi = true,
    AllowNone = true,
    Flag = "RaidDiff_Cfg",
    Values = raidList,
    Callback = function(val)
        local t = {};
        for _, v in pairs(val) do
            table.insert(t, type(v) == "table" and v.Value or v);
        end;
        Config.TargetRaid = t;
    end
});
FM_Add("Gamemodes", RaidDrop);
local DefenseDrop = FarmTab:Dropdown({
    Title = "Select Defense",
    Multi = true,
    AllowNone = true,
    Flag = "DefenseDiff_Cfg",
    Values = defenseList,
    Callback = function(val)
        local t = {};
        for _, v in pairs(val) do
            table.insert(t, type(v) == "table" and v.Value or v);
        end;
        Config.TargetDefense = t;
    end
});
FM_Add("Gamemodes", DefenseDrop);

task.spawn(function()
    local function GetNextTimeDiff(times, currentMin, currentSec)
        if not times or #times == 0 then return 0 end
        table.sort(times)

        for _, t in ipairs(times) do
            if t > currentMin then
                return (t - currentMin) * 60 - currentSec
            end
        end

        local firstTime = times[1]
        return (60 - currentMin + firstTime) * 60 - currentSec
    end

    while not Window.Destroyed do
        local t = os.date("*t")
        local currentMin = t.min
        local currentSec = t.sec

        local newRaidList = {}
        for _, item in ipairs(raidList) do
            local rName = item.Value
            local data = raidDB[rName]
            if data and data.Times then
                local diff = GetNextTimeDiff(data.Times, currentMin, currentSec)
                if diff < 0 then diff = 0 end

                local m = math.floor(diff / 60)
                local s = diff % 60
                local timeStr = string.format("%02d:%02d", m, s)

                table.insert(newRaidList, {
                    Title = item.Title,
                    Value = item.Value,
                    Desc = data.BaseDesc .. " | Starts in: " .. timeStr
                })
            else
                table.insert(newRaidList, item)
            end
        end

        if RaidDrop and RaidDrop.Refresh then
            pcall(function() RaidDrop:Refresh(newRaidList) end)
        end

        local newDefenseList = {}
        for _, item in ipairs(defenseList) do
            local dName = item.Value
            local data = defenseDB[dName]
            if data and data.Times then
                local diff = GetNextTimeDiff(data.Times, currentMin, currentSec)
                if diff < 0 then diff = 0 end

                local m = math.floor(diff / 60)
                local s = diff % 60
                local timeStr = string.format("%02d:%02d", m, s)

                table.insert(newDefenseList, {
                    Title = item.Title,
                    Value = item.Value,
                    Desc = data.BaseDesc .. " | Starts in: " .. timeStr
                })
            else
                table.insert(newDefenseList, item)
            end
        end

        if DefenseDrop and DefenseDrop.Refresh then
            pcall(function() DefenseDrop:Refresh(newDefenseList) end)
        end

        task.wait(1)
    end
end)

local ModeToggle = FarmTab:Toggle({
    Title = "Auto Join & Kill",
    Flag = "AutoDungeon_Cfg",
    Callback = function(val)
        Config.AutoDungeon = val;
        if val then
            task.spawn(LogicGamemodes);
        end;
    end
});
FM_Add("Gamemodes", ModeToggle);

-- [ACCESSORIES UI]
local function UpdateAccDropdown(dropdown, val, defaultTitle)
    local selectedId = type(val) == "table" and val.Value or val
    if selectedId then
        local info = AccessoriesConfig[selectedId]
        if info then
            dropdown:SetTitle(info.Display)
            local icon = "rbxassetid://84366761557806"
            if info.Template then
                icon = "rbxassetid://" .. tostring(info.Template)
            end
            dropdown:SetIcon(icon, 30)
            dropdown:SetDesc(info.Rarity or "Accessory")
        else
            dropdown:SetTitle(selectedId)
            dropdown:SetIcon("rbxassetid://84366761557806", 30)
            dropdown:SetDesc("Unknown")
        end
    else
        dropdown:SetTitle(defaultTitle or "Select Gear")
        dropdown:SetDesc("None Selected")
        dropdown:SetIcon("rbxassetid://84366761557806", 20)
    end
end

local AccInMode
AccInMode = FarmTab:Dropdown({
    Title = "Select Battle Gear",
    Desc = "None Selected",
    Multi = false,
    Values = GetOwnedAccessories(),
    Image = "rbxassetid://84366761557806",
    ImageSize = 20,
    Flag = "AccInMode_Cfg",
    Callback = function(val)
        local v = type(val) == "table" and val.Value or val
        Config.AccessoryInMode = v
        UpdateAccDropdown(AccInMode, v, "Select Battle Gear")
    end
})
FM_Add("Accessories", AccInMode)

if Config.AccessoryInMode then
    UpdateAccDropdown(AccInMode, Config.AccessoryInMode, "Select Battle Gear")
end

local AccOutMode
AccOutMode = FarmTab:Dropdown({
    Title = "Select Lobby Gear",
    Desc = "None Selected",
    Multi = false,
    Values = GetOwnedAccessories(),
    Image = "rbxassetid://84366761557806",
    ImageSize = 20,
    Flag = "AccOutMode_Cfg",
    Callback = function(val)
        local v = type(val) == "table" and val.Value or val
        Config.AccessoryOutMode = v
        UpdateAccDropdown(AccOutMode, v, "Select Lobby Gear")
    end
})
FM_Add("Accessories", AccOutMode)

if Config.AccessoryOutMode then
    UpdateAccDropdown(AccOutMode, Config.AccessoryOutMode, "Select Lobby Gear")
end

local RefreshAccBtn = FarmTab:Button({
    Title = "Refresh Accessories",
    Icon = "refresh-cw",
    Callback = function()
        local list = GetOwnedAccessories()
        AccInMode:Refresh(list)
        AccOutMode:Refresh(list)
        
        if Config.AccessoryInMode then UpdateAccDropdown(AccInMode, Config.AccessoryInMode, "Select Battle Gear") end
        if Config.AccessoryOutMode then UpdateAccDropdown(AccOutMode, Config.AccessoryOutMode, "Select Lobby Gear") end
    end
})
FM_Add("Accessories", RefreshAccBtn)

local AccToggle = FarmTab:Toggle({
    Title = "Auto Equip Accessories",
    Flag = "AutoEquipAcc_Cfg",
    Callback = function(val)
        Config.AutoEquipAccessories = val
        if val then
            task.spawn(LogicGamemodes)
        end;
    end
})
FM_Add("Accessories", AccToggle)

FM_OnChange("Zone Farming")

local GeneralTab = Window:Tab({
    Title = "General",
    Icon = "settings"
});

local GeneralManagerSection = FarmTab
local ExchangeList = {}
for k, v in pairs(MaterialsModule) do
    if v.Exchangeable and k ~= "TradeToken" then
        table.insert(ExchangeList, {Title = v.Display, Value = k})
    end
end
table.sort(ExchangeList, function(a,b) return a.Title < b.Title end)

local SelectedExToken = nil
local SelectedExIcon = nil
local PrevMaterialsDigest = nil
local ExchangeAmount = 1
local ExchangeIsBuying = false

-- moved earlier

local function GetMaterialsDigest()
    local pData = (getgenv()).PlayerData
    local keys = {}
    if pData and pData.Materials then
        for k,_ in pairs(pData.Materials) do
            table.insert(keys, k)
        end
    end
    table.sort(keys)
    return table.concat(keys, "|")
end

local function BuildExchangeValues()
    local pData = (getgenv()).PlayerData
    local mats = {}
    for _, item in ipairs(ExchangeList) do
        local key = item.Value
        local info = MaterialsModule[key]
        local count = (pData and pData.Materials and pData.Materials[key]) or 0
        local img = info and info.Template and GetIcon(info.Template) or ""
        table.insert(mats, {
            Title = item.Title,
            Icon = img,
            Value = key,
        })
    end
    return mats
end

local PreviewGroup = GeneralManagerSection:Group()
FM_Add("Exchange", PreviewGroup)

local MatPreview = PreviewGroup:Dropdown({
    Title = "Select Token",
    Desc = "None Selected",
    Image = "rbxassetid://84366761557806",
    ImageSize = 20,
    Values = BuildExchangeValues(),
    Multi = false,
    Callback = function(val)
        SelectedExToken = type(val) == "table" and val.Value or val
        SelectedExIcon = type(val) == "table" and val.Icon or nil
        local info = SelectedExToken and MaterialsModule[SelectedExToken] or nil
        if info and info.Template then
            MatPreview:SetTitle(info.Display)
            MatPreview:SetIcon(SelectedExIcon or GetIcon(info.Template), 30)
            local pData = (getgenv()).PlayerData
            local matCount = pData and pData.Materials and pData.Materials[SelectedExToken] or 0
            MatPreview:SetDesc(string.format("(%s/%s)", FormatNumber(ExchangeAmount), FormatNumber(matCount)))
        end
    end
})
MatPreview:Refresh(BuildExchangeValues())

local TradePreview = PreviewGroup:Paragraph({
    Title = TradeTokenInfo.Display,
    Desc = "Waiting...",
    Image = GetIcon(TradeTokenInfo.Template),
    ImageSize = 40
})


local ExchangePercent = 1
local ExSlider = GeneralManagerSection:Slider({
    Title = "Amount %",
    Min = 0,
    Max = 100,
    Default = 100,
    Callback = function(v)
        ExchangePercent = v / 100
    end
})
FM_Add("Exchange", ExSlider)

local ExSwap = GeneralManagerSection:Toggle({
    Title = "Swap Direction (Buy Mode)",
    Desc = "OFF: Material -> Trade Token | ON: Trade Token -> Material",
    Callback = function(v)
        ExchangeIsBuying = v
    end
})
FM_Add("Exchange", ExSwap)

local ExchangeButton = GeneralManagerSection:Button({
    Title = "Exchange",
    Icon = "check",
    Callback = function()
        if not SelectedExToken then
            l:Notify({Title="Error", Content="Select a token first!", Icon="alert-triangle"})
            return
        end

        local args = {
            "Convert Tokens",
            {
                SelectedExToken,
                ExchangeIsBuying,
                ExchangePercent
            }
        }

        if Reliable then
            pcall(function()
                Reliable:FireServer(unpack(args))
            end)
            l:Notify({Title="Exchange", Content="Request Sent!", Icon="send"})
        end
    end
})
FM_Add("Exchange", ExchangeButton)

task.spawn(function()
    while not Window.Destroyed do
        local pData = (getgenv()).PlayerData
        local digest = GetMaterialsDigest()
        if digest ~= PrevMaterialsDigest then
            MatPreview:Refresh(BuildExchangeValues())
            PrevMaterialsDigest = digest
        end

        local tradeCount = (pData and pData.Materials and pData.Materials["TradeToken"]) or 0
        local matCount = (SelectedExToken and pData and pData.Materials and pData.Materials[SelectedExToken]) or 0

        local inputAmount = 0
        local outputAmount = 0

        if ExchangeIsBuying then
            inputAmount = math.floor(tradeCount * ExchangePercent)
            outputAmount = inputAmount
        else
            local rawInput = math.floor(matCount * ExchangePercent)
            outputAmount = math.floor(rawInput / 10)
            inputAmount = rawInput
        end

        if SelectedExToken then
            local info = MaterialsModule[SelectedExToken]
            if info and info.Template then
                MatPreview:SetTitle(info.Display)
                MatPreview:SetIcon(SelectedExIcon or GetIcon(info.Template), 30)

                if ExchangeIsBuying then
                     MatPreview:SetDesc(string.format("Current: %s | +%s", FormatNumber(matCount), FormatNumber(outputAmount)))
                else
                     MatPreview:SetDesc(string.format("Current: %s | -%s", FormatNumber(matCount), FormatNumber(inputAmount)))
                end
            end

            if ExchangeIsBuying then
                TradePreview:SetDesc(string.format("Current: %s | -%s", FormatNumber(tradeCount), FormatNumber(inputAmount)))
            else
                TradePreview:SetDesc(string.format("Current: %s | +%s", FormatNumber(tradeCount), FormatNumber(outputAmount)))
            end
        else
            MatPreview:SetTitle("Select Token")
            MatPreview:SetDesc("None Selected")
            MatPreview:SetIcon("rbxassetid://84366761557806", 20)
            TradePreview:SetDesc("Waiting...")
        end
        task.wait(0.5)
    end
end)

local _rollGroup;
local _rollCount = 0;
for _, rollType in ipairs(AllRollTypes) do
    if _rollCount % 2 == 0 then
        _rollGroup = GeneralManagerSection:Group({});
        FM_Add("Crate Roll", _rollGroup)
    end;
    local tokenKey = (RollConfigs[rollType] and RollConfigs[rollType].MaterialKey) or (rollType .. "Token");
    local displayName = (MaterialsModule[tokenKey] and MaterialsModule[tokenKey].Display) or rollType;
    local currentCount = (((getgenv()).PlayerData and (getgenv()).PlayerData.Materials) and (getgenv()).PlayerData.Materials[tokenKey]) or 0;
    local configFlag = "AutoRoll" .. rollType;
    local myToggle = _rollGroup:Toggle({
        Title = rollType,
        Flag = configFlag .. "_Cfg",
        Desc = displayName .. ": " .. FormatNumber(currentCount),
        Image = GetRollIconAsset(rollType),
        ImageSize = 24,
        Callback = function(val)
            Config[configFlag] = val;
        end
    });
    RollToggleUI[rollType] = myToggle;
    _rollCount = _rollCount + 1;
end;

task.spawn(function()
    while not Window.Destroyed do
        local pData = (getgenv()).PlayerData;
        if pData then
            if pData.Materials then
                for rollType, toggle in pairs(RollToggleUI) do
                    local tokenKey = (RollConfigs[rollType] and RollConfigs[rollType].MaterialKey) or (rollType .. "Token");
                    local displayName = (MaterialsModule[tokenKey] and MaterialsModule[tokenKey].Display) or rollType;
                    local currentCount = pData.Materials[tokenKey] or 0;
                    pcall(function()
                        if not Window.Closed then
                            toggle:SetDesc(displayName .. ": " .. FormatNumber(currentCount));
                        end
                    end);
                end;
            end;

            if pData.Vault then
                for rollType, toggle in pairs(RollToggleUI) do
                    local isMaxed = false;
                    if rollType == "Race" and pData.Vault[rollType] and pData.Vault[rollType]["6"] == true then
                        isMaxed = true;
                    elseif pData.Vault[rollType] and pData.Vault[rollType]["7"] == true then
                        isMaxed = true;
                    end;

                    if isMaxed then
                        pcall(function()
                            toggle:Lock();
                            toggle:SetTitle(rollType .. " [MAX]");
                            if Config["AutoRoll" .. rollType] then
                                Config["AutoRoll" .. rollType] = false;
                                toggle:Set(false);
                            end;
                        end);
                    end;
                end;
            end;
        end;
        task.wait(1);
    end;
end);

GeneralTab:Toggle({
    Title = "Auto Fuse Weapons",
    Flag = "AutoFuse_Cfg",
    Callback = function(val)
        Config.AutoFuse = val;
        if val then
            task.spawn(function()
                while Config.AutoFuse do
                    if Window.Destroyed then
                        break;
                    end;
                    if Reliable then
                        pcall(function()
                            Reliable:FireServer("Weapon Fuse All");
                        end);
                    end;
                    task.wait(5);
                end;
            end);
        end;
    end
});

local function GetStatsIcon()
    local icon = "bar-chart";
    pcall(function()
        icon = (game:GetService("Players")).LocalPlayer.PlayerGui.Screen.Hud.left.buttons.StatPoints.button.icon.Image;
    end);
    return icon;
end;
local YenMainSection = FarmTab
-- moved earlier
local upgradeOrder = {"Luck", "Damage", "Yen", "Mastery", "Critical"}

-- Using FarmTab categories; no sub-tab buttons needed

local _yenGroup
local _yenCount = 0
for _, name in ipairs(upgradeOrder) do
    if YenUpgradeConfig[name] then
        if _yenCount % 2 == 0 then
            _yenGroup = YenMainSection:Group({})
            FM_Add("Upgrade: Yen", _yenGroup)
        end
        local myToggle = _yenGroup:Toggle({
            Title = name, Flag = "AutoYen_" .. name, Callback = function(val) Config["AutoYen_" .. name] = val end
        })
        YenUpgradeToggleUI[name] = myToggle
        _yenCount = _yenCount + 1
    end
end

if TokenUpgradeConfig then
    local _tokenGroup
    local _tokenCount = 0
    local sortedTokens = {}
    for name, _ in pairs(TokenUpgradeConfig) do
        table.insert(sortedTokens, name)
    end
    table.sort(sortedTokens)

    for _, name in ipairs(sortedTokens) do
        if _tokenCount % 2 == 0 then
            _tokenGroup = YenMainSection:Group({})
            FM_Add("Upgrade: Token", _tokenGroup)
        end
        local myToggle = _tokenGroup:Toggle({
            Title = name, Flag = "AutoToken_" .. name, Callback = function(val) Config["AutoToken_" .. name] = val end
        })
        TokenUpgradeToggleUI[name] = myToggle
        _tokenCount = _tokenCount + 1
    end
end

RankProgressUI = YenMainSection:Paragraph({ Title = "Rank Progress", Desc = "Waiting for data...", Image = GetDynamicRankIcon(), ImageSize = 40 })
FM_Add("Upgrade: Rank", RankProgressUI)

local RankToggle = YenMainSection:Toggle({ Title = "Auto Rank Up", Flag = "AutoRankUp_Cfg", Callback = function(val) Config.AutoRankUp = val end })
FM_Add("Upgrade: Rank", RankToggle)

local _chanceGroup
local _chanceCount = 0
for _, name in ipairs(ChanceUpgradeTypes) do
    if _chanceCount % 2 == 0 then
        _chanceGroup = YenMainSection:Group({})
        FM_Add("Upgrade: Trainer", _chanceGroup)
    end
    local myToggle = _chanceGroup:Toggle({
        Title = "Loading...",
        Flag = "AutoChance_" .. name,
        Callback = function(val)
            Config["AutoChance_" .. name] = val
        end
    })
    ChanceUpgradeToggleUI[name] = myToggle
    _chanceCount = _chanceCount + 1
end

if MagicEyesModule then
    if _chanceCount % 2 == 0 then
        _chanceGroup = YenMainSection:Group({})
        FM_Add("Upgrade: Trainer", _chanceGroup)
    end

    local MagicEyeToggle = _chanceGroup:Toggle({
        Title = "Magic Eye Upgrade",
        Image = "rbxassetid://84366761557806",
        ImageSize = 24,
        Desc = "Loading...",
        Flag = "AutoUpgradeMagicEyes_Cfg",
        Callback = function(val)
            Config.AutoUpgradeMagicEyes = val
            if val then
                task.spawn(function()
                    while Config.AutoUpgradeMagicEyes and not Window.Destroyed do
                        if Reliable then
                            pcall(function()
                                Reliable:FireServer("Crate Upgrade", {"MagicEyes"})
                            end)
                        end
                        task.wait(1)
                    end
                end)
            end
        end
    })

    task.spawn(function()
        local function FormatBonus(bonuses)
            local str = ""
            for k, v in pairs(bonuses) do
                local displayValue = math.floor(v * 10) / 10
                str = str .. k .. ": " .. FormatNumber(displayValue) .. " "
            end
            return str
        end

        while not Window.Destroyed do
            local pData = getgenv().PlayerData
            local currentToken = 0
            if pData and pData.Materials and MagicEyesModule and MagicEyesModule.UpgradeMaterial then
                currentToken = pData.Materials[MagicEyesModule.UpgradeMaterial] or 0
            end;
            if pData and pData.Attributes and pData.GachaLevel and MagicEyesModule and MagicEyesModule.List then
                local equippedEyeIndex = pData.Attributes.MagicEyes
                local currentLevel = pData.GachaLevel.MagicEyes[tostring(equippedEyeIndex)]
                if currentLevel <= 0 then
                    currentLevel = 1                    
                end
                local equippedItemData = MagicEyesModule.List[equippedEyeIndex]
                if not Window.Closed then
                    if equippedItemData and equippedItemData.Template then
                        MagicEyeToggle:SetImage(GetIcon(equippedItemData.Template))
                    end
                end

                if currentLevel then

                    local maxLevel = MagicEyesModule.MaxLevel or 50

                    if currentLevel >= maxLevel then
                        if not Window.Closed then
                            MagicEyeToggle:SetDesc(string.format("Lvl: %s [MAX]", tostring(currentLevel)))
                            MagicEyeToggle:Lock()
                        end
                        if Config.AutoUpgradeMagicEyes then
                            Config.AutoUpgradeMagicEyes = false
                            MagicEyeToggle:Set(false)
                        end
                    elseif equippedItemData and equippedItemData.Bonus then
                        if not Window.Closed then
                            local cost = MagicEyesModule.GetCost(currentLevel)
                            local currentBonuses = MagicEyesModule.GetBonuses(currentLevel, equippedItemData.Bonus)
                            local nextBonuses = MagicEyesModule.GetBonuses(currentLevel + 1, equippedItemData.Bonus)

                            local bonusStr = FormatBonus(currentBonuses)
                            local nextBonusStr = FormatBonus(nextBonuses)

                            MagicEyeToggle:SetDesc(string.format(
                                "Used: %s(%s)\nLvl: %s/%s\nCost: %s \nUpgrade Eyes Shard: %s",
                                equippedItemData.Display,
                                equippedItemData.Rarity,
                                tostring(currentLevel),
                                tostring(maxLevel),
                                FormatNumber(cost),
                                FormatNumber(currentToken)
                            ))
                        end

                        local cost = MagicEyesModule.GetCost(currentLevel)
                        if currentToken < cost and Config.AutoUpgradeMagicEyes then
                            Config.AutoUpgradeMagicEyes = false
                            MagicEyeToggle:Set(false)
                        end
                    else
                        if not Window.Closed then
                            local cost = MagicEyesModule.GetCost and MagicEyesModule.GetCost(currentLevel) or "?"
                            MagicEyeToggle:SetDesc(string.format("Lvl: %s | Cost: %s (Item Data Missing: Index %s)", tostring(currentLevel), FormatNumber(cost), tostring(equippedEyeIndex)))
                        end
                    end
                else
                    if not Window.Closed then
                        local itemName = equippedItemData and equippedItemData.Display or "Unknown"
                        MagicEyeToggle:SetDesc(string.format("Used: %s | Lvl: 0 (Upgrade not started)", itemName))
                    end
                end
            end
            task.wait(1)
        end
    end)
    _chanceCount = _chanceCount + 1
end

if DemonArtModule then
    if _chanceCount % 2 == 0 then
        _chanceGroup = YenMainSection:Group({})
        FM_Add("Upgrade: Trainer", _chanceGroup)
    end

    local DemonArtToggle = _chanceGroup:Toggle({
        Title = "Demon Art Upgrade",
        Image = "rbxassetid://84366761557806",
        ImageSize = 24,
        Desc = "Loading...",
        Flag = "AutoUpgradeDemonArt_Cfg",
        Callback = function(val)
            Config.AutoUpgradeDemonArt = val
            if val then
                task.spawn(function()
                    while Config.AutoUpgradeDemonArt and not Window.Destroyed do
                        if Reliable then
                            pcall(function()
                                Reliable:FireServer("Crate Upgrade", {"DemonArt"})
                            end)
                        end
                        task.wait(1)
                    end
                end)
            end
        end
    })

    task.spawn(function()
        local function FormatBonus(bonuses)
            local str = ""
            for k, v in pairs(bonuses) do
                local displayValue = math.floor(v * 10) / 10
                str = str .. k .. ": " .. FormatNumber(displayValue) .. " "
            end
            return str
        end

        while not Window.Destroyed do
            local pData = getgenv().PlayerData
            local currentToken = 0
            if pData and pData.Materials and DemonArtModule and DemonArtModule.UpgradeMaterial then
                currentToken = pData.Materials[DemonArtModule.UpgradeMaterial] or 0
            end;
            if pData and pData.Attributes and pData.GachaLevel and DemonArtModule and DemonArtModule.List then
                local equippedArtIndex = pData.Attributes.DemonArt
                
                local currentLevel = pData.GachaLevel.DemonArt[tostring(equippedArtIndex)]
                if currentLevel <= 0 then
                    currentLevel = 1                    
                end
                local equippedItemData = DemonArtModule.List[equippedArtIndex]
                if not Window.Closed then
                    if equippedItemData and equippedItemData.Template then
                        DemonArtToggle:SetImage(GetIcon(equippedItemData.Template))
                    end
                end

                if currentLevel then

                    local maxLevel = DemonArtModule.MaxLevel or 50

                    if currentLevel >= maxLevel then
                        if not Window.Closed then
                            DemonArtToggle:SetDesc(string.format("Lvl: %s [MAX]", tostring(currentLevel)))
                            DemonArtToggle:Lock()
                        end
                        if Config.AutoUpgradeDemonArt then
                            Config.AutoUpgradeDemonArt = false
                            DemonArtToggle:Set(false)
                        end
                    elseif equippedItemData and equippedItemData.Bonus then
                        if not Window.Closed then
                            local cost = DemonArtModule.GetCost(currentLevel)
                            local currentBonuses = DemonArtModule.GetBonuses(currentLevel, equippedItemData.Bonus)
                            local nextBonuses = DemonArtModule.GetBonuses(currentLevel + 1, equippedItemData.Bonus)

                            local bonusStr = FormatBonus(currentBonuses)
                            local nextBonusStr = FormatBonus(nextBonuses)

                            DemonArtToggle:SetDesc(string.format(
                                "Used: %s(%s)\nLvl: %s/%s\nCost: %s \nUpgrade Demon Art Shard: %s",
                                equippedItemData.Display,
                                equippedItemData.Rarity,
                                tostring(currentLevel),
                                tostring(maxLevel),
                                FormatNumber(cost),
                                FormatNumber(currentToken)
                            ))
                        end

                        local cost = DemonArtModule.GetCost(currentLevel)
                        if currentToken < cost and Config.AutoUpgradeDemonArt then
                            Config.AutoUpgradeDemonArt = false
                            DemonArtToggle:Set(false)
                        end
                    else
                        if not Window.Closed then
                            local cost = DemonArtModule.GetCost and DemonArtModule.GetCost(currentLevel) or "?"
                            DemonArtToggle:SetDesc(string.format("Lvl: %s | Cost: %s (Item Data Missing: Index %s)", tostring(currentLevel), FormatNumber(cost), tostring(equippedArtIndex)))
                        end
                    end
                else
                    if not Window.Closed then
                        local itemName = equippedItemData and equippedItemData.Display or "Unknown"
                        local cost = DemonArtModule.GetCost(currentLevel)
                        DemonArtToggle:SetDesc(string.format("Used: %s | Lvl: 0 (Upgrade not started)\nCost: %s", itemName, FormatNumber(cost)))
                    end
                end
            end
            task.wait(1)
        end
    end)
    _chanceCount = _chanceCount + 1
end

local SettingsTab = Window:Tab({
    Title = "Settings",
    Icon = "settings-2"
});
local ConfigSection = SettingsTab:Section({
    Title = "Config Manager",
    Icon = "save",
    Opened = true
});
local ConfigName = "ANConfig";
SettingsTab:Input({
    Title = "Config Name",
    Placeholder = "ANConfig",
    Flag = "ConfigName_Input",
    Callback = function(txt)
        ConfigName = txt;
    end
});
SettingsTab:Button({
    Title = "Save Config",
    Icon = "save",
    Callback = function()
        (Window.ConfigManager:CreateConfig(ConfigName)):Save();
        if CurrentZoneName ~= "" and Config.SelectedEnemy then
            SaveZoneConfig(CurrentZoneName, Config.SelectedEnemy);
        end;
        Window:Notify({
            Title = "Success",
            Content = "Saved!",
            Icon = "check"
        });
    end
});
SettingsTab:Button({
    Title = "Load Config",
    Icon = "upload",
    Callback = function()
        local cfg = Window.ConfigManager:GetConfig(ConfigName);
        LoadZoneDB();
        if cfg then
            cfg:Load();
            Window:Notify({
                Title = "Success",
                Content = "Loaded!",
                Icon = "check"
            });
        end;
    end
});
SettingsTab:Button({
    Title = "Delete Config",
    Icon = "trash",
    Callback = function()
        Window.ConfigManager:DeleteConfig(ConfigName);
        Window:Notify({
            Title = "Success",
            Content = "Deleted!",
            Icon = "trash"
        });
    end
});
local SecuritySection = SettingsTab:Section({
    Title = "Game Security",
    Icon = "shield",
    Opened = true
});
SettingsTab:Paragraph({
    Title = "Game Auto Reconnect",
    Desc = "Status: FROZEN by ANHub\nBypass is running automatically."
});
if Reliable then
    Reliable.OnClientEvent:Connect(function(msg, args)
        if msg == "Do Teleport" and type(args) == "table" then
            local targetZoneName = args[1];
            IsTeleporting = true;
            IsLoadingConfig = true;
            CurrentZoneName = targetZoneName;
            Config.SelectedEnemy = nil;
            if EnemyDropdown and EnemyDropdown.Select then
                pcall(function()
                    EnemyDropdown:Select(nil);
                end);
            end;
            task.spawn(function()
                task.wait(2.5);
                local freshEnemies = RefreshEnemyData();
                CurrentZoneEnemiesCache = freshEnemies;
                if EnemyDropdown and EnemyDropdown.Refresh then
                    pcall(function()
                        EnemyDropdown:Refresh(freshEnemies);
                    end);
                end;
                local savedEntry = Config.ZoneConfigurations[targetZoneName];
                if savedEntry then
                    for _, enemy in ipairs(freshEnemies) do
                        if enemy.Value == savedEntry.Value then
                            Config.SelectedEnemy = enemy.Value;
                            if EnemyDropdown and EnemyDropdown.Select then
                                pcall(function()
                                    EnemyDropdown:Select(enemy.Value);
                                end);
                            end;
                            break;
                        end;
                    end;
                end;
                IsLoadingConfig = false;
                IsTeleporting = false;
            end);
        end;
    end);
end;
task.spawn(function()
    local prevZone = "";
    local refreshTick = 0;
    while not Window.Destroyed do
        task.wait(0.5);
        if not IsTeleporting then
            local detectedZone = GetCurrentMapStatus();
            if detectedZone and detectedZone ~= "Unknown" and detectedZone ~= prevZone then
                prevZone = detectedZone;
                CurrentZoneName = detectedZone;
                Config.SelectedEnemy = nil;
                if EnemyDropdown and EnemyDropdown.Select then
                    pcall(function()
                        EnemyDropdown:Select(nil);
                    end);
                end;
                IsLoadingConfig = true;
                local freshEnemies = RefreshEnemyData();
                CurrentZoneEnemiesCache = freshEnemies;
                pcall(function()
                    EnemyDropdown:Refresh(freshEnemies);
                end);
                task.wait(0.2);
                local savedEntry = Config.ZoneConfigurations[detectedZone];
                local objectToSelect = nil;
                if savedEntry then
                    for _, currentMob in ipairs(freshEnemies) do
                        if currentMob.Value == savedEntry.Value then
                            objectToSelect = currentMob;
                            Config.SelectedEnemy = currentMob.Value;
                            break;
                        end;
                    end;
                end;
                if objectToSelect then
                    pcall(function()
                        EnemyDropdown:Select(objectToSelect.Value);
                    end);
                end;
                task.wait(0.2);
                IsLoadingConfig = false;
            end;
        end;
    end;
end);
local LastMorphCount = 0;
local LastEquippedAvatar = "";
task.spawn(function()
    while not Window.Destroyed do
        if not (getgenv()).PlayerData then
            ScanPlayerData();
        end;
        local Data = (getgenv()).PlayerData;
        if Data and Data.Attributes then
            local currentRank = Data.Attributes.Rank or 0;
            local currentMastery = Data.Attributes.Mastery or 0;
            local req = GetRankRequirement(currentRank);
            local currentBuff = GetRankBuff(currentRank);
            local nextBuff = GetRankBuff(currentRank + 1);
            if RankProgressUI and not Window.Closed then
                local percent = req > 0 and math.clamp(currentMastery / req, 0, 1) or 0;
                local barText = string.rep("", math.floor(percent * 10)) .. string.rep("", 10 - math.floor(percent * 10));
                local buffText = currentRank >= MaxRankCap and "Buff: " .. FormatNumber(currentBuff) .. "% (MAX)" or "Buff: " .. FormatNumber(currentBuff) .. "% >> " .. FormatNumber(nextBuff) .. "%";
                RankProgressUI:SetTitle(string.format("Rank %d", currentRank));
                RankProgressUI:SetDesc(string.format("%s\n[%s] %d%%\n%s / %s", buffText, barText, math.floor(percent * 100), FormatNumber(currentMastery), FormatNumber(req)));
            end;
            if Config.AutoRankUp and currentMastery >= req and currentRank < MaxRankCap then
                if Reliable then
                    pcall(function()
                        Reliable:FireServer("RankUp");
                    end);
                end;
            end;
            if Data.YenUpgrades then
                local currentYen = Data.Attributes.Yen or 0;
                for name, configData in pairs(YenUpgradeConfig) do
                    local lvl = Data.YenUpgrades[name] or 0;
                    local cost = GetYenCost(lvl);
                    local toggle = YenUpgradeToggleUI[name];
                    if toggle and toggle.SetTitle and toggle.SetDesc then
                        local maxLvl = configData.MaxLevel or 20;
                        if lvl >= maxLvl then
                            if not Window.Closed then
                                toggle:SetTitle(name .. " [MAX]");
                                toggle:Lock();
                                toggle:SetDesc(string.format("Maxed Out (Buff: +%s%%)", FormatNumber(GetYenBuff(name, lvl))));
                            end
                        else
                            if not Window.Closed then
                                toggle:SetTitle(name .. " [" .. lvl .. "/" .. maxLvl .. "]");
                                toggle:SetDesc(string.format("Cost: %s | Buff: +%s%%", FormatNumber(cost), FormatNumber(GetYenBuff(name, lvl))));
                            end
                            if Config["AutoYen_" .. name] and currentYen >= cost then
                                if Reliable then
                                    pcall(function()
                                        Reliable:FireServer("Yen Upgrade", {
                                            name
                                        });
                                    end);
                                end;
                            end;
                        end;
                    end;
                end;
            end;
            if Data.TokenUpgrades then
                local currentToken = Data.Materials.UpgradeToken or 0;
                for name, configData in pairs(TokenUpgradeConfig) do
                    local lvl = Data.TokenUpgrades[name] or 0;
                    local cost = GetTokenCost(lvl,name);
                    local toggle = TokenUpgradeToggleUI[name];
                    if toggle and toggle.SetTitle and toggle.SetDesc then
                        local maxLvl = configData.MaxLevel or 999;
                        if lvl >= maxLvl then
                            if not Window.Closed then
                                toggle:Lock();
                                toggle:SetTitle(name .. " [MAX]");
                                toggle:SetDesc(string.format("Maxed Out (Buff: +%s%%)", FormatNumber(GetTokenBuff(name, lvl))));
                            end
                        else
                            if not Window.Closed then
                                toggle:SetTitle(name .. " [" .. lvl .. "/" .. maxLvl .. "]");
                                toggle:SetDesc(string.format("Cost: %s | Buff: +%s%%\nUpgrade Shard: %s", FormatNumber(cost), FormatNumber(GetTokenBuff(name, lvl)), FormatNumber(currentToken)));
                            end
                            if Config["AutoToken_" .. name] and currentToken >= cost then
                                if Reliable then
                                    pcall(function()
                                        Reliable:FireServer("Token Upgrade", {
                                            name
                                        });
                                    end);
                                end;
                            end;
                        end;
                    end;
                end;
            end;
            if Data.CrateUpgrades then
                for name, toggleObj in pairs(ChanceUpgradeToggleUI) do
                    local mod = ChanceModules[name];
                    if mod and toggleObj.SetTitle and toggleObj.SetDesc then
                        local lvl = Data.CrateUpgrades[name] or 0;
                        local maxLvl = mod.MAX_LEVEL or 10;
                        local cost = mod.GetCost(lvl);
                        local chance = string.format("%.1f", mod.GetChance(lvl));
                        local tokenKey = mod.TOKEN_NAME or name .. "Token";
                        local currentMaterial = Data.Materials[tokenKey] or 0;
                        local displayName = tokenKey;
                        if MaterialsModule[tokenKey] and MaterialsModule[tokenKey].Display then
                            displayName = MaterialsModule[tokenKey].Display;
                        end;
                        if lvl >= maxLvl then
                            if not Window.Closed then
                                toggleObj:SetTitle(name .. " [MAX]");
                                toggleObj:SetDesc("Max Level Reached");
                                toggleObj:Lock();
                            end
                        else
                            if not Window.Closed then
                                toggleObj:SetTitle(string.format("%s [%d/%d]", name, lvl, maxLvl));
                                toggleObj:SetDesc(string.format("Cost: %s | Chance: %s%%\n%s: %s", FormatNumber(cost), chance, displayName, FormatNumber(currentMaterial)));
                            end
                            if Config["AutoChance_" .. name] then
                                if currentMaterial >= cost then
                                    if Reliable then
                                        Reliable:FireServer("Chance Upgrade", {
                                            name
                                        });
                                    end;
                                end;
                            end;
                        end;
                    end;
                end;
            end;
            if Data.Materials then
                for rollType, toggleObj in pairs(RollToggleUI) do
                    local configKey = "AutoRoll" .. rollType;
                    if Config[configKey] then
                        local tokenKey = (RollConfigs[rollType] and RollConfigs[rollType].MaterialKey) or (rollType .. "Token");
                        local count = Data.Materials[tokenKey] or 0;
                        if count < 10 then
                            Config[configKey] = false;
                            if toggleObj.Set then
                                toggleObj:Set(false);
                            end;
                            local displayName = (MaterialsModule[tokenKey] and MaterialsModule[tokenKey].Display) or rollType;
                            l:Notify({
                                Title = "Crate Roll Stopped",
                                Content = "Insufficient " .. displayName,
                                Icon = "alert-triangle",
                                Duration = 5
                            });
                        end;
                    end;
                end;
            end;
        elseif RankProgressUI then
            RankProgressUI:SetDesc("Scanning Data...");
        end;
        task.wait(1);
    end;
end);
task.spawn(MaintainAutoStatus);
task.spawn(function()
    task.wait(1.5);
    local DefaultConfig = "ANConfig";
    local CM = Window.ConfigManager;

    if not isfolder((FolderPath .. "/config")) then
        makefolder(FolderPath .. "/config");
    end;
    pcall(function()
        if isfile(FolderPath .. "/config/" .. DefaultConfig .. ".json") then
            local cfg = CM:GetConfig(DefaultConfig) or CM:CreateConfig(DefaultConfig);
            cfg:Load();
            LoadZoneDB();
            l:Notify({
                Title = "Config",
                Content = "Restored ANConfig",
                Icon = "check",
                Duration = 2
            });
        else
            CM:CreateConfig(DefaultConfig);
        end;
    end);
    while not Window.Destroyed do
        task.wait(10);
        pcall(function()
            local cfg = Window.ConfigManager:GetConfig(DefaultConfig);
            if cfg then
                cfg:Save();
            else
                (CM:CreateConfig(DefaultConfig)):Save();
            end;
        end);
        if CurrentZoneName ~= "" and Config.SelectedEnemy then
            SaveZoneConfig(CurrentZoneName, Config.SelectedEnemy);
        end;
    end;
end);
local AllSections = {
    CommunitySection,
    FarmTab,
    ConfigSection,
    SecuritySection
};
for _, sec in pairs(AllSections) do
    task.spawn(function()
        task.wait(0.1);
        if sec.Opened then
            sec:Open();
        end;
    end);
end;
Window:SelectTab(FarmTab.Index);
